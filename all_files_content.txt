=== Файл: ./backend/app/config.py ===
import os
import secrets
from pathlib import Path

BASE_DIR   = Path(__file__).resolve().parent.parent
UPLOAD_DIR = BASE_DIR / "uploads"
UPLOAD_DIR.mkdir(exist_ok=True)

DATABASE_URL = os.getenv("DATABASE_URL") or f"sqlite:///{BASE_DIR / 'journal.db'}"

SQLALCHEMY_DATABASE_URL = DATABASE_URL

SECRET_KEY   = os.getenv("SECRET_KEY") or secrets.token_urlsafe(32)
ALGORITHM    = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7

PORT = int(os.getenv("PORT", 8000))
=== Конец файла: ./backend/app/config.py ===

=== Файл: ./backend/app/crud.py ===
from datetime import datetime
from sqlalchemy.orm import Session
from .models import User, Group, Shooting, Exercise, group_members
from .schemas import UserCreate, GroupCreate, ShootingCreate, ExerciseCreate
from .utils import hash_pw, verify_pw, write_upload
import secrets, bcrypt
from .models import TeacherInvite

def get_user_by_username(db: Session, username: str) -> User | None:
    return db.query(User).filter(User.username == username).first()

def get_user_by_id(db: Session, user_id: int) -> User | None:
    return db.get(User, user_id)

def create_user(db: Session, obj: UserCreate, is_teacher: bool, teacher_id: int | None) -> User:
    u = User(
        username=obj.username,
        hashed_pw=hash_pw(obj.password),
        is_teacher=is_teacher,
        teacher_id=teacher_id,
    )
    db.add(u); db.commit(); db.refresh(u)
    return u

def create_group(db: Session, owner: User, name: str) -> Group:
    g = Group(name=name, owner_id=owner.id)
    db.add(g); db.commit(); db.refresh(g)
    return g

def add_student_to_group(db: Session, group: Group, student: User):
    stmt = group_members.insert().values(group_id=group.id, student_id=student.id)
    db.execute(stmt); db.commit()

def create_shooting(db: Session, student: User, obj: ShootingCreate, photo_path: str) -> Shooting:
    sh = Shooting(
        student_id=student.id,
        group_id=obj.group_id,
        exercise_id=obj.exercise_id,
        note=obj.note,
        canvas_json=obj.canvas_json,
        photo_path=photo_path,
        time_spent=obj.time_spent,      
        hits_count=obj.hits_count,      
    )
    db.add(sh); db.commit(); db.refresh(sh)
    return sh

def list_shootings(db: Session, teacher: User, student_id: int | None = None, group_id: int | None = None):
    q = db.query(Shooting).join(User, User.id == Shooting.student_id)
    if not teacher.is_teacher:
        q = q.filter(Shooting.student_id == teacher.id)
    else:
        q = q.filter(User.teacher_id == teacher.id)
        if student_id: q = q.filter(Shooting.student_id == student_id)
        if group_id:   q = q.filter(Shooting.group_id == group_id)
    return q.order_by(Shooting.created_at.desc()).all()

# --------- exercises ---------
def create_exercise(db: Session, owner: User, obj: ExerciseCreate, img_path: str) -> Exercise:
    ex = Exercise(
        name=obj.name,
        target_img=img_path,
        max_hits=obj.max_hits,
        time_sec=obj.time_sec,
        owner_id=owner.id,
    )
    db.add(ex); db.commit(); db.refresh(ex)
    return ex

def list_exercises(db: Session, teacher: User) -> list[Exercise]:
    return db.query(Exercise).filter(Exercise.owner_id == teacher.id).order_by(Exercise.created_at.desc()).all()

def list_shootings(
    db: Session,
    teacher: User,
    student_id: int | None = None,
    group_id: int | None = None,
    exercise_id: int | None = None,
    hits_from: int | None = None,
    hits_to: int | None = None,
    time_from: int | None = None,
    time_to: int | None = None,
) -> list[Shooting]:
    q = db.query(Shooting).join(User, User.id == Shooting.student_id)

    if not teacher.is_teacher:
        q = q.filter(Shooting.student_id == teacher.id)
    else:
        q = q.filter(User.teacher_id == teacher.id)
        if student_id:  q = q.filter(Shooting.student_id == student_id)
        if group_id:    q = q.filter(Shooting.group_id == group_id)

    if exercise_id: q = q.filter(Shooting.exercise_id == exercise_id)

    # фильтр по кол-ву попаданий (json-массив canvas_json)
    if hits_from is not None or hits_to is not None:
        from sqlalchemy import func
        hits_cnt = func.json_array_length(Shooting.canvas_json)
        if hits_from is not None:  q = q.filter(hits_cnt >= hits_from)
        if hits_to   is not None:  q = q.filter(hits_cnt <= hits_to)

    # фильтр по времени (секунды в time_sec упражнения)
    if time_from is not None or time_to is not None:
        if time_from is not None:  q = q.join(Exercise).filter(Exercise.time_sec >= time_from)
        if time_to   is not None:  q = q.join(Exercise).filter(Exercise.time_sec <= time_to)

    return q.order_by(Shooting.created_at.desc()).all() 

def create_teacher_invite(db: Session, admin: User, plain_password: str) -> TeacherInvite:
    rec = TeacherInvite(
        code=secrets.token_urlsafe(8)[:8],
        password=hash_pw(plain_password),
        created_by=admin.id,
    )
    db.add(rec)
    db.commit()
    db.refresh(rec)
    return rec

def consume_teacher_invite(db: Session, code: str, plain_password: str) -> TeacherInvite | None:
    inv = db.query(TeacherInvite).filter(
        TeacherInvite.code == code,
        TeacherInvite.is_used == False
    ).first()
    if not inv or not verify_pw(plain_password, inv.password):
        return None
    inv.is_used = True
    inv.used_at = datetime.utcnow()
    db.commit()
    return inv
=== Конец файла: ./backend/app/crud.py ===

=== Файл: ./backend/app/database.py ===
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from .config import SQLALCHEMY_DATABASE_URL
from .models import Base

engine = create_engine(SQLALCHEMY_DATABASE_URL, pool_pre_ping=True, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, autoflush=False, future=True)

def create_all():
    Base.metadata.create_all(bind=engine)
=== Конец файла: ./backend/app/database.py ===

=== Файл: ./backend/app/deps.py ===
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session
from .config import SECRET_KEY, ALGORITHM
from .models import User
from .crud import get_user_by_id
from .database import SessionLocal

oauth2 = OAuth2PasswordBearer(tokenUrl="/auth/token")

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

async def get_current_user(token: str = Depends(oauth2), db: Session = Depends(get_db)) -> User:
    creds_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = int(payload.get("sub"))
    except (JWTError, ValueError):
        raise creds_exception
    user = get_user_by_id(db, user_id)
    if not user:
        raise creds_exception
    return user
=== Конец файла: ./backend/app/deps.py ===

=== Файл: ./backend/app/gunicorn.conf.py ===
import os

bind = f"0.0.0.0:{os.getenv('PORT', 8080)}"
workers = 2
worker_class = "uvicorn.workers.UvicornWorker"
timeout = 120
graceful_timeout = 120
keepalive = 2
preload_app = True
=== Конец файла: ./backend/app/gunicorn.conf.py ===

=== Файл: ./backend/app/__init__.py ===
[Бинарный файл - содержимое не отображается]

=== Конец файла: ./backend/app/__init__.py ===

=== Файл: ./backend/app/main.py ===
# backend/app/main.py
import os
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from .database import create_all
from .config import UPLOAD_DIR, PORT
from .routers import auth, invites, groups, students, shootings, exercises

app = FastAPI(title="ShootingJournal", version="0.1")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://vasyminusov-jornal-frontend-8898.twc1.net"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

create_all()

app.mount("/uploads", StaticFiles(directory=UPLOAD_DIR), name="uploads")

for r in (auth, invites, groups, students, shootings, exercises):
    app.include_router(r.router)

# SPA fallback
@app.get("/{full_path:path}")
async def spa(full_path: str):
    if full_path.startswith("api") or full_path.startswith("uploads"):
        return
    return FileResponse("static/index.html")

# health-check
@app.get("/health")
def health():
    return {"status": "ok"}

# создаём первого учителя, если БД пуста
from sqlalchemy.orm import Session
from .database import SessionLocal
from .crud import create_user
from .schemas import UserCreate

def create_first_teacher():
    db: Session = SessionLocal()
    if db.query(User).first() is None:
        create_user(db, UserCreate(username="Admin", password=" ", invite_code="TEACHER"), is_teacher=True, teacher_id=None)
    db.close()

create_first_teacher()

# удобный запуск локально
if __name__ == "__main__":
    import uvicorn
    uvicorn.run("app.main:app", host="0.0.0.0", port=PORT)
=== Конец файла: ./backend/app/main.py ===

=== Файл: ./backend/app/models.py ===
from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey, Boolean, Table, text
from sqlalchemy.orm import declarative_base, relationship
from datetime import datetime

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    id          = Column(Integer, primary_key=True, index=True)
    username    = Column(String(80), unique=True, index=True)
    hashed_pw   = Column(String(120))
    is_teacher  = Column(Boolean, default=False)
    teacher_id  = Column(Integer, ForeignKey("users.id"), nullable=True)
    created_at  = Column(DateTime, default=datetime.utcnow)

    teacher     = relationship("User", remote_side=[id], backref="students")
    groups      = relationship("Group", back_populates="owner")
    shootings   = relationship("Shooting", back_populates="student")
    exercises   = relationship("Exercise", back_populates="owner")

class Group(Base):
    __tablename__ = "groups"
    id        = Column(Integer, primary_key=True, index=True)
    name      = Column(String(120))
    owner_id  = Column(Integer, ForeignKey("users.id"))
    created_at= Column(DateTime, default=datetime.utcnow)
    owner     = relationship("User", back_populates="groups")
    students  = relationship("User", secondary="group_members")

group_members = Table(
    "group_members",
    Base.metadata,
    Column("group_id", ForeignKey("groups.id"), primary_key=True),
    Column("student_id", ForeignKey("users.id"), primary_key=True),
)

class Exercise(Base):
    __tablename__ = "exercises"
    id        = Column(Integer, primary_key=True, index=True)
    name      = Column(String(200), nullable=False)
    target_img= Column(String(250), nullable=False)
    max_hits  = Column(Integer, default=10)
    time_sec  = Column(Integer, default=0)
    owner_id  = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at= Column(DateTime, default=datetime.utcnow)

    owner     = relationship("User", back_populates="exercises")
    shootings = relationship("Shooting", back_populates="exercise_ref")

    @property
    def target_url(self) -> str:
        return f"/uploads/{self.target_img}"

class Shooting(Base):
    __tablename__ = "shootings"
    id          = Column(Integer, primary_key=True, index=True)
    student_id  = Column(Integer, ForeignKey("users.id"), nullable=False)
    group_id    = Column(Integer, ForeignKey("groups.id"), nullable=True)  # Убедитесь что nullable=True
    exercise_id = Column(Integer, ForeignKey("exercises.id"), nullable=False)
    note        = Column(Text)
    canvas_json = Column(Text)
    photo_path  = Column(String(250))
    created_at  = Column(DateTime, default=datetime.utcnow)
    time_spent = Column(Integer, default=0)
    hits_count = Column(Integer, default=0)
    student     = relationship("User", back_populates="shootings")
    group       = relationship("Group")  # Убедитесь что relationship правильно настроен
    exercise_ref= relationship("Exercise", back_populates="shootings")

    @property
    def photo_url(self) -> str:
        return f"/uploads/{self.photo_path}"

    @property
    def exercise(self) -> "Exercise":
        return self.exercise_ref
    
class TeacherInvite(Base):
    __tablename__ = "teacher_invites"
    id          = Column(Integer, primary_key=True, index=True)
    code        = Column(String(64), unique=True, nullable=False)   
    password    = Column(String(120), nullable=False)               
    created_by  = Column(Integer, ForeignKey("users.id"), nullable=False)
    is_used     = Column(Boolean, default=False)
    created_at  = Column(DateTime, default=datetime.utcnow)
    used_at     = Column(DateTime)  
=== Конец файла: ./backend/app/models.py ===

=== Файл: ./backend/app/routers/auth.py ===
from fastapi import APIRouter, Depends, HTTPException, status
from pydantic import BaseModel
from sqlalchemy.orm import Session
from fastapi.security import OAuth2PasswordRequestForm
from ..models import User
from ..deps import get_current_user
from datetime import timedelta
from jose import jwt
from ..deps import get_db
from .. import crud
from ..schemas import Token, UserCreate, UserOut
from ..config import SECRET_KEY, ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES
from ..utils import verify_pw
from ..crud import consume_teacher_invite, create_user

router = APIRouter(prefix="/auth", tags=["auth"])

class FinishInvite(BaseModel):
    code: str
    password: str          # пароль из ссылки
    username: str
    new_password: str

@router.post("/token", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), db: Session = Depends(get_db)):
    user = crud.get_user_by_username(db, form_data.username)
    if not user or not verify_pw(form_data.password, user.hashed_pw):
        raise HTTPException(status_code=400, detail="Incorrect username or password")
    token = jwt.encode({"sub": str(user.id)}, SECRET_KEY, algorithm=ALGORITHM)
    return {"access_token": token, "token_type": "bearer"}

@router.post("/register", response_model=UserOut)
def register(obj: UserCreate, db: Session = Depends(get_db)):
    # проверим invite_code == teacher или student
    teacher_invite = obj.invite_code == "TEACHER"   # первого учителя создаём вручную
    student_invite = obj.invite_code.startswith("STU")
    if not (teacher_invite or student_invite):
        raise HTTPException(400, "bad invite code")

    if crud.get_user_by_username(db, obj.username):
        raise HTTPException(400, "username taken")

    teacher_id = None
    if student_invite:
        # код = STU<teacher_id>
        try:
            teacher_id = int(obj.invite_code[3:])
        except ValueError:
            raise HTTPException(400, "bad student invite")
        t = crud.get_user_by_id(db, teacher_id)
        if not t or not t.is_teacher:
            raise HTTPException(400, "teacher not found")

    user = crud.create_user(db, obj, is_teacher=teacher_invite, teacher_id=teacher_id)
    return user

@router.get("/me", response_model=UserOut)
def me(u: User = Depends(get_current_user)):
    return u

@router.post("/finish-invite")
def finish_invite(data: FinishInvite, db: Session = Depends(get_db)):
    inv = consume_teacher_invite(db, data.code, data.password)
    if not inv:
        raise HTTPException(400, "bad invite")
    # создаём учителя
    user = create_user(
        db,
        UserCreate(username=data.username, password=data.new_password, invite_code="TEACHER"),
        is_teacher=True,
        teacher_id=None
    )
    return UserOut.from_orm(user)
=== Конец файла: ./backend/app/routers/auth.py ===

=== Файл: ./backend/app/routers/exercises.py ===
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import List
from ..deps import get_db, get_current_user
from ..models import User, Exercise
from ..schemas import ExerciseOut, ExerciseCreate
from ..crud import create_exercise, list_exercises
from ..utils import write_upload

router = APIRouter(prefix="/exercises", tags=["exercises"])

@router.get("/", response_model=List[ExerciseOut])
def get_exercises(teacher: User = Depends(get_current_user), db: Session = Depends(get_db)):
    if not teacher.is_teacher:
        raise HTTPException(403, "teachers only")
    return list_exercises(db, teacher)

@router.post("/", response_model=ExerciseOut)
def add_exercise(
    name: str = Form(...),
    max_hits: int = Form(10),
    time_sec: int = Form(0),
    target: UploadFile = File(...),
    teacher: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    if not teacher.is_teacher:
        raise HTTPException(403, "teachers only")
    fname = write_upload(target.file.read(), target.filename)
    ex = create_exercise(db, teacher, ExerciseCreate(name=name, max_hits=max_hits, time_sec=time_sec), fname)
    return ex

@router.get("/my-teacher", response_model=List[ExerciseOut])
def get_teacher_exercises(student: User = Depends(get_current_user), db: Session = Depends(get_db)):
    """Студент получает список упражнений своего преподавателя"""
    if student.is_teacher:
        raise HTTPException(403, "students only")
    if not student.teacher_id:
        raise HTTPException(404, "no teacher assigned")
    return db.query(Exercise).filter(Exercise.owner_id == student.teacher_id).order_by(Exercise.created_at.desc()).all()

@router.get("/available", response_model=List[ExerciseOut])
def get_available_exercises(
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Возвращает доступные упражнения в зависимости от роли пользователя"""
    if user.is_teacher:
        # Преподаватель видит свои упражнения
        return list_exercises(db, user)
    else:
        # Студент видит упражнения своего преподавателя
        if not user.teacher_id:
            raise HTTPException(404, "no teacher assigned")
        return db.query(Exercise).filter(
            Exercise.owner_id == user.teacher_id
        ).order_by(Exercise.created_at.desc()).all()
=== Конец файла: ./backend/app/routers/exercises.py ===

=== Файл: ./backend/app/routers/groups.py ===
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from ..deps import get_db, get_current_user
from .. import crud
from ..schemas import GroupCreate, GroupOut
from typing import List
from ..models import Group

router = APIRouter(prefix="/groups", tags=["groups"])

@router.post("/", response_model=GroupOut)
def create_group(obj: GroupCreate, db: Session = Depends(get_db), u = Depends(get_current_user)):
    if not u.is_teacher:
        return {"detail": "forbidden"}
    return crud.create_group(db, u, obj.name)

@router.get("/", response_model=List[GroupOut])
def my_groups(db: Session = Depends(get_db), u = Depends(get_current_user)):
    if u.is_teacher:
        return u.groups

    from ..models import group_members
    from sqlalchemy import select
    ids = db.execute(select(group_members.c.group_id).where(group_members.c.student_id == u.id)).scalars().all()
    return db.query(Group).filter(Group.id.in_(ids)).all()
=== Конец файла: ./backend/app/routers/groups.py ===

=== Файл: ./backend/app/routers/__init__.py ===
[Бинарный файл - содержимое не отображается]

=== Конец файла: ./backend/app/routers/__init__.py ===

=== Файл: ./backend/app/routers/invites.py ===
from fastapi import APIRouter, Depends, HTTPException
from ..deps import get_current_user, get_db
from ..models import User
from pydantic import BaseModel
from ..crud import create_teacher_invite, consume_teacher_invite
from sqlalchemy.orm import Session

router = APIRouter(prefix="/invites", tags=["invites"])

class TeacherInviteOut(BaseModel):
    code: str
    password: str          
    link: str             

class TeacherInviteCreate(BaseModel):
    password: str

@router.get("/teacher")
def teacher_invite(user: User = Depends(get_current_user)):
    if not user.is_teacher:
        return {"detail": "forbidden"}
    return {"invite_code": "TEACHER"}   

@router.get("/student")
def student_invite(user: User = Depends(get_current_user)):
    if not user.is_teacher:
        return {"detail": "forbidden"}
    return {"invite_code": f"STU{user.id}"}

@router.post("/teacher-link", response_model=TeacherInviteOut)
def make_teacher_link(
    payload: TeacherInviteCreate,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db),          
):
    if not user.is_teacher:
        raise HTTPException(403, "only teachers")
    invite = create_teacher_invite(db, user, payload.password) 
    base = "http://localhost:5173"
    return TeacherInviteOut(
        code=invite.code,
        password=payload.password,
        link=f"{base}/finish-invite?code={invite.code}"
    )

@router.post("/check-invite")
def check_invite(data: dict, db: Session = Depends(get_db)):
    code = data.get("code")
    password = data.get("password")
    inv = consume_teacher_invite(db, code, password)
    if not inv:
        raise HTTPException(400, "bad code or password or already used")
    return {"ok": True}
=== Конец файла: ./backend/app/routers/invites.py ===

=== Файл: ./backend/app/routers/shootings.py ===
from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, Form
from sqlalchemy.orm import Session
from typing import Optional
from ..deps import get_db, get_current_user
from .. import crud
from ..crud import create_shooting
from ..models import User, Exercise
from ..schemas import ShootingCreate, ShootingOut
from ..utils import write_upload
from typing import List, Optional
from fastapi import Query

router = APIRouter(prefix="/shootings", tags=["shootings"])

@router.post("/", response_model=ShootingOut)
def add_shooting(
    exercise_id: int = Form(...),
    note: Optional[str] = Form(""),
    canvas_json: str = Form(...),
    group_id: Optional[int] = Form(None),  # Исправлено: теперь правильно обрабатывается
    time_spent: int = Form(..., ge=0),        
    hits_count: int = Form(..., ge=0),        
    photo: UploadFile = File(...),
    student: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    if student.is_teacher:
        raise HTTPException(403, "teachers cannot shoot")
    ex = db.get(Exercise, exercise_id)
    if not ex:
        raise HTTPException(404, "exercise not found")

    if hits_count > ex.max_hits:
        raise HTTPException(400, f"max hits for exercise is {ex.max_hits}")
    if ex.time_sec and time_spent > ex.time_sec:
        raise HTTPException(400, f"max time for exercise is {ex.time_sec} s")

    # Проверяем, что группа принадлежит учителю студента
    if group_id:
        from ..models import Group
        group = db.get(Group, group_id)
        if not group:
            raise HTTPException(404, "group not found")
        
        # Проверяем, что студент состоит в этой группе
        from ..models import group_members
        student_in_group = db.query(group_members).filter(
            group_members.c.group_id == group_id,
            group_members.c.student_id == student.id
        ).first()
        
        if not student_in_group:
            raise HTTPException(403, "student is not member of this group")

    fname = write_upload(photo.file.read(), photo.filename)
    obj = ShootingCreate(
        exercise_id=exercise_id,
        note=note,
        canvas_json=canvas_json,
        group_id=group_id,  # Теперь передается правильно
        time_spent=time_spent,
        hits_count=hits_count,
    )
    sh = create_shooting(db, student, obj, fname)
    return sh

@router.get("/", response_model=List[ShootingOut])
def list_shootings(
    student_id: Optional[int] = Query(None),
    group_id: Optional[int] = Query(None),
    exercise_id: Optional[int] = Query(None),
    hits_from: Optional[int] = Query(None, ge=0),
    hits_to: Optional[int] = Query(None, ge=0),
    time_from: Optional[int] = Query(None, ge=0),
    time_to: Optional[int] = Query(None, ge=0),
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    print(f"Filter params: student_id={student_id}, group_id={group_id}, exercise_id={exercise_id}, "
          f"hits_from={hits_from}, hits_to={hits_to}, time_from={time_from}, time_to={time_to}")
    
    result = crud.list_shootings(
        db=db,
        teacher=user,
        student_id=student_id,
        group_id=group_id,
        exercise_id=exercise_id,
        hits_from=hits_from,
        hits_to=hits_to,
        time_from=time_from,
        time_to=time_to
    )
    
    print(f"Found {len(result)} results")
    return result
=== Конец файла: ./backend/app/routers/shootings.py ===

=== Файл: ./backend/app/routers/students.py ===
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from pydantic import BaseModel, Field
from ..deps import get_db, get_current_user
from ..models import User
from ..schemas import UserOut
from ..crud import create_user, add_student_to_group
from typing import List
from sqlalchemy import exists

router = APIRouter(prefix="/students", tags=["students"])

class StudentCreateByTeacher(BaseModel):
    username: str
    password: str
    group_id: int | None = Field(None, description="Сразу добавить в группу")

@router.get("/", response_model=List[UserOut])
def my_students(db: Session = Depends(get_db), teacher = Depends(get_current_user)):
    if not teacher.is_teacher:
        raise HTTPException(403)
    return teacher.students


@router.get("/without-group", response_model=List[UserOut])
def students_without_group(db: Session = Depends(get_db), teacher = Depends(get_current_user)):
    """Студы без группы (чтобы можно было добавлять)"""
    if not teacher.is_teacher:
        raise HTTPException(403)
    from ..models import group_members
    # студенты учителя, которых нет ни в одной группе
    sub = db.query(group_members.c.student_id).subquery()
    q = db.query(User).filter(
        User.teacher_id == teacher.id,
        User.is_teacher == False,
        ~User.id.in_(sub)
    )
    return q.all()

@router.post("/create", response_model=UserOut)
def create_student(
    payload: StudentCreateByTeacher,
    db: Session = Depends(get_db),
    teacher=Depends(get_current_user),
):
    if not teacher.is_teacher:
        raise HTTPException(403, "only teachers can create students")
    if db.query(User).filter(User.username == payload.username).first():
        raise HTTPException(400, "username already exists")

    # создаём ученика
    student = create_user(
        db, payload, is_teacher=False, teacher_id=teacher.id
    )

    # сразу в группу, если выбрали
    if payload.group_id:
        from ..models import Group
        g = db.get(Group, payload.group_id)
        if not g or g.owner_id != teacher.id:
            raise HTTPException(404, "group not found")
        add_student_to_group(db, g, student)

    return student
=== Конец файла: ./backend/app/routers/students.py ===

=== Файл: ./backend/app/schemas.py ===
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List

# --------- базовые схемы ---------
class UserCreate(BaseModel):
    username: str = Field(..., min_length=3, max_length=30)
    password: str = Field(..., min_length=4)
    invite_code: str

class UserOut(BaseModel):
    id: int
    username: str
    is_teacher: bool
    created_at: datetime
    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

class GroupCreate(BaseModel):
    name: str

class GroupOut(BaseModel):
    id: int
    name: str
    created_at: datetime
    class Config:
        from_attributes = True

# --------- упражнения ---------
class ExerciseCreate(BaseModel):
    name: str
    max_hits: int = Field(10, ge=1)
    time_sec: int = Field(0, ge=0)

class ExerciseOut(BaseModel):
    id: int
    name: str
    target_url: str
    max_hits: int
    time_sec: int
    created_at: datetime
    class Config:
        from_attributes = True

# --------- стрельбы ---------
class ShootingCreate(BaseModel):
    exercise_id: int
    note: Optional[str] = ""
    canvas_json: str
    group_id: Optional[int] = None  # Исправлено: теперь правильный тип
    time_spent: int = Field(..., ge=0)        
    hits_count: int = Field(..., ge=0)

class ShootingOut(BaseModel):
    id: int
    exercise: ExerciseOut          # property модели
    note: str
    canvas_json: str
    photo_url: str                 # property модели
    created_at: datetime
    time_spent: int      
    hits_count: int
    student: UserOut
    group: Optional[GroupOut]      # Исправлено: теперь Optional
    class Config:
        from_attributes = True
=== Конец файла: ./backend/app/schemas.py ===

=== Файл: ./backend/app/utils.py ===
import uuid, os
from pathlib import Path
from passlib.context import CryptContext

pwd_ctx = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_pw(pw: str) -> str:
    return pwd_ctx.hash(pw[:72])

def verify_pw(pw: str, hashed: str) -> bool:
    return pwd_ctx.verify(pw[:72], hashed)

def write_upload(file_bytes: bytes, original_name: str) -> str:
    ext = Path(original_name).suffix
    name = f"{uuid.uuid4()}{ext}"
    path = Path("uploads") / name
    with open(path, "wb") as f:
        f.write(file_bytes)
    return name
=== Конец файла: ./backend/app/utils.py ===

=== Файл: ./backend/requirements.txt ===
fastapi==0.111
uvicorn[standard]
sqlalchemy>=2.0
alembic
python-multipart
python-jose[cryptography]
passlib[bcrypt]==1.7.4
bcrypt==4.2.0
aiofiles
pydantic
gunicorn
=== Конец файла: ./backend/requirements.txt ===

=== Файл: ./to_text.sh ===
#!/bin/bash

# Файл для вывода
OUTPUT_FILE="all_files_content.txt"

# Список исключений (через пробел)
EXCLUDE_LIST="node_modules .next .git __pycache__ v1 infra  *.module.css Readme.md models *.log init tests package-lock.json venv all_files_content.txt venv pnpm-lock.yaml"

# Функция для проверки, нужно ли исключить файл/директорию
should_exclude() {
    local item="$1"
    for pattern in $EXCLUDE_LIST; do
        if [[ "$item" == $pattern ]]; then
            return 0  # true - исключить
        fi
    done
    return 1  # false - не исключать
}

# Очищаем файл вывода
> "$OUTPUT_FILE"

# Функция для обработки директории
process_directory() {
    local dir="$1"
    
    for item in "$dir"/*; do
        # Получаем только имя файла/директории
        local base_name=$(basename "$item")
        
        # Пропускаем текущую и родительскую директории
        if [[ "$base_name" == "." || "$base_name" == ".." ]]; then
            continue
        fi
        
        # Проверяем исключения
        if should_exclude "$base_name"; then
            echo "Пропускаем: $item" >&2
            continue
        fi
        
        if [[ -d "$item" ]]; then
            # Это директория - рекурсивно обрабатываем
            echo "Обрабатываем директорию: $item" >&2
            process_directory "$item"
        elif [[ -f "$item" ]]; then
            # Это файл - записываем его содержимое
            echo "Обрабатываем файл: $item" >&2
            echo "=== Файл: $item ===" >> "$OUTPUT_FILE"
            
            # Пытаемся прочитать файл как текст
            if file "$item" | grep -q "text"; then
                cat "$item" >> "$OUTPUT_FILE" 2>/dev/null
            else
                echo "[Бинарный файл - содержимое не отображается]" >> "$OUTPUT_FILE"
            fi
            
            echo -e "\n=== Конец файла: $item ===\n" >> "$OUTPUT_FILE"
        fi
    done
}

# Запускаем обработку с текущей директории
echo "Начинаем обработку файлов..."
process_directory "."

echo "Готово! Все файлы записаны в: $OUTPUT_FILE"
=== Конец файла: ./to_text.sh ===

